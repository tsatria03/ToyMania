key@[]keys(0);
class key
{
bool autobreak;
int getsound, hurtsound, keysound, spawnsound;
int kx;
int ky;
int timeout;
string keytype;
string keytype2;
timer timeout_timer;
key(int x,int y,int tt,string kt,string kt2,bool br)
{
kx=x;
ky=y;
timeout=tt;
keytype=kt;
keytype2=kt2;
autobreak=br;
spawnsound=keypool.play_2d(get_sound("equipments/items/normal/keys/"+keytype+"/"+keytype2+"/*spawn*"), me.x, me.y, kx, ky, false);
keysound=keypool.play_2d(get_sound("equipments/items/normal/keys/"+keytype+"/"+keytype2+"/*loop*"), me.x, me.y, kx, ky, true);
keypool.update_sound_2d(spawnsound,kx,ky);
keypool.update_sound_2d(keysound,kx,ky);
}
}
void keyloop()
{
for(uint i=0; i<keys.length(); i++)
{
if(keys[i].timeout_timer.elapsed>=keys[i].timeout and keys[i].autobreak==true)
{
keypool.destroy_sound(keys[i].keysound);
keys[i].hurtsound=keypool.play_2d(get_sound("equipments/items/normal/keys/"+keys[i].keytype+"/"+keys[i].keytype2+"/*break*"), me.x, me.y, keys[i].kx, keys[i].ky, false);
keys.remove_at(i);
return;
}
if(absolute(me.x - keys[i].kx) <= 2 and absolute(me.y - keys[i].ky) <= 2)
{
keypool.destroy_sound(keys[i].keysound);
keys[i].getsound=keypool.play_stationary(get_sound("equipments/items/normal/keys/"+keys[i].keytype+"/"+keys[i].keytype2+"/*get*"),false);
if (!endless)
{
if (play_item_gives==true) p.play_stationary(get_sound("misc/player/*give*"), false);
give(keys[i].keytype2, 1);
if (speak_item_collects==true) speak(keys[i].keytype2);
}
collected_keys+=1;
total_collected_keys+=1;
update_achievements();
writedata();
keys.remove_at(i);
return;
}
}
}
void spawn_key(int x,int y,int timeout,string keytype,string keytype2,bool autobreak)
{
    if (!endless && doors.length() > 0 && collected_keys >= doors[0].required_keys)
        return;
    key key1(x,y,timeout,keytype,keytype2,autobreak);
    keys.insert_last(key1);
}
void destroy_all_keys()
{
for(uint i=0; i<keys.length(); i++)
{
keypool.destroy_sound(keys[i].keysound);
}
keys.resize(0);
}
