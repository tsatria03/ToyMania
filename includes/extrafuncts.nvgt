bool alt_is_down()
{
if(key_down(KEY_LMENU) or key_down(KEY_RMENU))
{
return true;
}
return false;
}
bool control_is_down()
{
if(key_down(KEY_LCONTROL) or key_down(KEY_RCONTROL))
{
return true;
}
return false;
}
bool shift_is_down()
{
if(key_down(KEY_LSHIFT) or key_down(KEY_RSHIFT))
{
return true;
}
return false;
}
bool int_to_bool(int i)
{
return i==1? true:false;
}
bool is_admin()
{
library l;
l.load("shell32.dll");
dictionary@ d = l.call("bool IsUserAnAdmin()");
return bool(d["0"]);
}
bool array_contains(const string[]& arr, const string& value)
{
for (uint i = 0; i < arr.length(); i++)
{
if (arr[i] == value)
{
return true;
}
}
return false;
}
bool preglobals()
{
if (!SCREEN_READER_AVAILABLE)
{
alert("error", "cannot load screen reader components");
}
else if (!SOUND_AVAILABLE)
{
alert("error", "cannot load soundsystem");
}
else
{
return true;
}
return false;
}
bool string_starts_with(const string& in str, const string& in start)
{
if (str.length()>=start.length())
{
return (str.substr(0, start.length()) == start);
}
return false;
}
bool string_ends_with(const string& in str,const string& in ending)
{
if (str.length()>=ending.length())
{
return (str.substr(str.length()-ending.length())==ending);
}
return false;
}
double clamp(double value, double min, double max)
{
value=value<min? min:value;
value=value>max? max:value;
return value;
}
double min(double a, double b)
{
return (a < b) ? a : b;
}
double max(double a, double b)
{
return (a > b) ? a : b;
}

double convert_to_pan(double length, double index, double range1, double range2)
{
try
{
double range = range2 - range1;
double percent = index / (length - 1);
double value = range1 + range * percent;
return value;
}
catch
{
return 0;
}
}
double convert_to_volume(double length,double index,double min_volume=-100,double max_volume=0)
{
try
{
double range=max_volume-min_volume;
double percent=index/(length-1);
double value=min_volume+range*percent;
return value;
}
catch
{
return 0;
}
}
double convert_to_pitch(double length,double index,double min_pitch=0,double max_pitch=200)
{
try
{
double range=max_pitch-min_pitch;
double percent=index/(length-1);
double value=min_pitch+range*percent;
return value;
}
catch
{
return 100;
}
}

int bool_to_int(bool b)
{
return b? 1:0;
}
int get_total_entities()
{
    return cars.length() + bullets.length() + gards.length() + toys.length() + objs.length() + keys.length();
}
float string_to_float(string str)
{
    float result = 0.0f;
    float fraction = 0.0f;
    float divisor = 10.0f;
    bool isNegative = false;
    bool inFraction = false;
    if (str.length() == 0)
        return 0.0f;
    if (str.substr(0, 1) == "-")
    {
        isNegative = true;
        str = str.substr(1);
    }
    for (uint i = 0; i < str.length(); i++)
    {
        string c = str.substr(i, 1);
        if (c == ".")
        {
            if (inFraction)
                break;
            inFraction = true;
            continue;
        }
        int digit = 0;
        if (c == "0") digit = 0;
        else if (c == "1") digit = 1;
        else if (c == "2") digit = 2;
        else if (c == "3") digit = 3;
        else if (c == "4") digit = 4;
        else if (c == "5") digit = 5;
        else if (c == "6") digit = 6;
        else if (c == "7") digit = 7;
        else if (c == "8") digit = 8;
        else if (c == "9") digit = 9;
        else
            break;
        if (!inFraction)
        {
            result = result * 10.0f + float(digit);
        }
        else
        {
            fraction += float(digit) / divisor;
            divisor *= 10.0f;
        }
    }
    result += fraction;
    return isNegative ? -result : result;
}

int string_to_int(string str)
{
    int result = 0;
    bool isNegative = false;
    if (str.length() == 0)
        return 0;
    if (str.substr(0, 1) == "-")
    {
        isNegative = true;
        str = str.substr(1);
    }
    for (uint i = 0; i < str.length(); i++)
    {
        string digitStr = str.substr(i, 1);
        int digit = 0;
        if (digitStr == "0") digit = 0;
        else if (digitStr == "1") digit = 1;
        else if (digitStr == "2") digit = 2;
        else if (digitStr == "3") digit = 3;
        else if (digitStr == "4") digit = 4;
        else if (digitStr == "5") digit = 5;
        else if (digitStr == "6") digit = 6;
        else if (digitStr == "7") digit = 7;
        else if (digitStr == "8") digit = 8;
        else if (digitStr == "9") digit = 9;
        else return 0;
        result = result * 10 + digit;
    }
    return isNegative ? -result : result;
}
string find_sound_in_disk(string soundname)
{
string[] snd=find_files(soundname);
if (snd.length()>0)
{
string[] a_path=string_split(soundname,"/",true);
string path=string_replace(soundname,a_path[a_path.length()-1],"",true);
return path+snd[random(0,snd.length()-1)];
}
else
return "";
}
string find_sound_in_pack(const string name, const string format = "", pack@[] packs = {})
{
uint l1, l2, l3;
pack@ p;
string[] files;
string wildcards = "%0.*".format(name);
string ffile;
string[] formats = {"ogg", "mp3", "wav"};
regexp re("^%0\\.(%1)$".format(name, (format.empty()) ? join(formats, "|") : format), RE_CASELESS);
packs.insert_last(sound_default_pack);
l1 = packs.length();
for (uint i = 0; i < l1; i ++) {
@p = @packs[i];
if (p == null)
continue;
files = p.list_files();
l2 = files.length();
for (uint j = 0; j < l2; j ++) {
if (re.match(files[j]))
return files[j];
}
}
files = find_files(wildcards);
l3 = files.length();
if (l3 < 1)
return "";
for (uint i = 0; i < l3; i ++) {
if (re.match(files[i]))
return files[i];
}
return "";
}
string get_sound(const string&in path, bool search_packs = false)
{
string fullpath = "sounds/" + soundpack + "/" + path;
return search_packs ? find_sound_in_pack(fullpath) : find_sound_in_disk(fullpath);
}
string gmt(double x, double y)
{
string mt;
for(uint i=0; i<platforms.length(); i++)
{
if(platforms[i].minx<=x and platforms[i].maxx>=x and platforms[i].miny<=y and platforms[i].maxy>=y)
{
mt=platforms[i].tile;
}
}
return mt;
}

string loadfilesmenu(string intro="", string dir="", string ext="", bool hide_ext=true)
{
string[] files=find_files(dir+"/*"+ext);
if(files.length() <= 0)
{
return "0";
}
setupmenu(false);
for(uint i=0; i<files.length(); i++)
{
if(hide_ext==false)
{
m.add_item(files[i], files[i]);
}
else
{
m.add_item(string_replace(files[i], ext, "", true), files[i]);
}
}
m.intro_text=intro;
int mres=m.run();
if(mres==-1)
{
return "";
}
else
{
return m.get_item_id(mres);
}
}
string loadfoldersmenu(string intro="select a folder", string dir="")
{
string[] folders=find_directories(dir);
if(folders.length() <= 0)
{
return "0";
}
setupmenu(false);
for(uint i=0; i<folders.length(); i++)
{
m.add_item(folders[i], folders[i]);
}
m.intro_text=intro;
int mres=m.run();
if(mres==0)
{
return "";
}
else
{
return m.get_item_id(mres);
}
}

string measure_file_size(int64 bytes)
{
if(bytes<1024)
{
return bytes+"bytes";
}
else if(bytes<1024*1024)
{
return round(double(bytes)/1024,2)+"KB";
}
else if(bytes<1024*1024*1024)
{
return round(double(bytes)/(1024*1024),2)+"MB";
}
else 
{
return round(double(bytes)/(1024*1024*1024),2)+"GB";
}
}
string measure_time_units(int64 milliseconds)
{
int64 seconds = milliseconds / 1000;
if(seconds < 1)
{
return milliseconds + " ms";
}
else if(seconds < 60)
{
int whole_seconds = int(seconds);
int ms = int(milliseconds % 1000);
return whole_seconds + " seconds, " + ms + " ms";
}
else if(seconds < 3600)
{
int minutes = int(seconds / 60);
int remaining_seconds = int(seconds % 60);
int ms = int(milliseconds % 1000);
return minutes + " minutes, " + remaining_seconds + " seconds, " + ms + " ms";
}
else
{
int hours = int(seconds / 3600);
int minutes = int((seconds % 3600) / 60);
int remaining_seconds = int(seconds % 60);
int ms = int(milliseconds % 1000);
return hours + " hours, " + minutes + " minutes, " + remaining_seconds + " seconds, " + ms + " ms";
}
}
string string_join(string[]@ arr, string delimiter=" ", int start_index = 0)
{
if(arr.length()<=0 or delimiter.is_empty()) return "";
string val;
for(int i=start_index; i<arr.length()-1; i++)
{
val += arr[i]+delimiter;
}
val += arr[arr.length()-1];
return val;
}
string trim(const string&in str)
{
string result = str;
while (result.length() > 0 && (string_left(result, 1) == " " || string_left(result, 1) == "\n" || string_left(result, 1) == "\r"))
{
result = string_trim_left(result, 1);
}
while (result.length() > 0 && (string_right(result, 1) == " " || string_right(result, 1) == "\n" || string_right(result, 1) == "\r"))
{
result = string_trim_right(result, 1);
}
return result;
}
string string_trim_sides(const string& in str)
{
string result=str;
while (result.length()>0 && (result[0]==" "||result[0]=="\t"||result[0]=="\r"||result[0]=="\n"))
{
result=string_trim_left(result,1);
}
while (result.length()>0 && (result[result.length()-1]==" "||result[result.length()-1]=="\t"||result[result.length()-1]=="\r"||result[result.length()-1]=="\n"))
{
result=string_trim_right(result,1);
}
return result;
}
string random_string(string[] array)
{
string retval=array[random(0,array.length()-1)];
return retval;
}
string strip_extension(string filename)
{
    int dotIndex = filename.rfind(".");
    if (dotIndex != -1)
    {
        return filename.substr(0, dotIndex);
    }
    return filename;
}
string strip_directory(string path)
{
    int lastSlash = path.rfind("/");
    if (lastSlash == -1)
        lastSlash = path.rfind("\\");
    if (lastSlash != -1)
        return path.substr(lastSlash + 1);
    return path;
}
uint64 get_directory_size(const string&in dir)
{
uint64 result=0;
string[]@ subdirs = find_directories(dir + "/*");
for (uint i = 0; i < subdirs.length(); i++)
{
result += get_directory_size(dir + "/" + subdirs[i]);
}
string[]@ files = find_files(dir + "/*");
for (uint i = 0; i < files.length(); i++)
{
result += file_get_size(dir + "/" + files[i]);
}
return result;
}
void apply_pitch_pool_settings()
{
int pitchValue = behind_pitch ? 5 : 0;
p.behind_pitch_decrease = pitchValue;
bosspool.behind_pitch_decrease = pitchValue;
doorpool.behind_pitch_decrease = pitchValue;
carpool.behind_pitch_decrease = pitchValue;
gardpool.behind_pitch_decrease = pitchValue;
healpool.behind_pitch_decrease = pitchValue;
objpool.behind_pitch_decrease = pitchValue;
keypool.behind_pitch_decrease = pitchValue;
toypool.behind_pitch_decrease = pitchValue;
}
void apply_misc_pool_settings()
{
p.max_distance = 0;
p.pan_step = 2.5;
p.volume_step = 2.5;
bosspool.max_distance = 0;
bosspool.pan_step = 2.5;
bosspool.volume_step = 2.5;
bulletpool.max_distance = 0;
bulletpool.pan_step = 2.5;
bulletpool.volume_step = 2.5;
doorpool.max_distance = 0;
doorpool.pan_step = 2.5;
doorpool.volume_step = 2.5;
carpool.max_distance = 0;
carpool.pan_step = 2.5;
carpool.volume_step = 2.5;
gardpool.max_distance = 0;
gardpool.pan_step = 2.5;
gardpool.volume_step = 2.5;
healpool.max_distance = 0;
healpool.pan_step = 2.5;
healpool.volume_step = 2.5;
keypool.max_distance = 0;
keypool.pan_step = 2.5;
keypool.volume_step = 2.5;
objpool.max_distance = 0;
objpool.pan_step = 2.5;
objpool.volume_step = 2.5;
toypool.max_distance = 0;
toypool.pan_step = 2.5;
toypool.volume_step = 2.5;
}
void dockread(const string&in filename)
{
if(!file_exists(filename))
{
alert("Error", "Could not fined "+string_replace(filename, "docks/", "", true));
docksmenu();
}
dockfile.open(filename,"rb");
string docktext=dockfile.read();
dockfile.close();
form.reset();
form.create_window("Viewing "+string_replace(filename, "docks/", "", true),false,false,false);
int dockbox=form.create_input_box(string_replace(filename, "docks/", "", true), docktext, read_only:true, multiline:true);
int dockclose=form.create_button("&close",false,true);
form.focus(dockbox);
while(true)
{
wait(5);
form.monitor();
if (form.is_pressed(dockclose))
{
docksmenu();
}
}
}
void fade(sound@ handle, double final_volume = -50, double delay = 25)
{
if (handle.volume == final_volume or !handle.active)
return;
while(round(handle.volume, 0) != round(final_volume, 0) and handle.playing) {
if (handle.volume > final_volume)
handle.volume = handle.volume - 1;
else if (handle.volume < final_volume)
handle.volume = handle.volume + 1;
else
break;
wait (delay);
}
}

void fade_multi_pool(int fade_mode=1, int fade_dir=0, double fade_pitch=50, double fade_volume=-50, bool stop_completely=true)
{
sound_pool@[] pools = {p, pool, alarmpool, ambpool, bulletpool, dartpool, doorpool, heartpool, healpool, objpool, muspool, thiefpool, bosspool, carpool, gardpool, keypool, toypool};
if(fade_mode==0)
{
fade_pitch_pool(pools, pitchmode:fade_dir, target_pitch:fade_pitch, stopsounds:stop_completely);
}
if(fade_mode==1)
{
fade_volume_pool(pools, volmode:fade_dir, target_volume:fade_volume, stopsounds:stop_completely);
}
}
void fade_pitch_pool(sound_pool@[] handles, double pitchtime = 25, double target_pitch = 50, double amount = 2, int pitchmode = 0, bool stopsounds = true)
{
    bool all_faded = false;
    while (!all_faded)
    {
        all_faded = true;
        for (uint h = 0; h < handles.length(); h++)
        {
            for (uint i = 0; i < handles[h].items.length(); i++)
            {
                if (@handles[h].items[i].handle == null || !handles[h].items[i].handle.playing)
                    continue;
                double current_pitch = handles[h].items[i].handle.pitch;
                if (pitchmode == 0 && current_pitch > target_pitch)
                {
                    double new_pitch = current_pitch - amount;
                    if (new_pitch < target_pitch)
                        new_pitch = target_pitch;
                    handles[h].items[i].handle.pitch = new_pitch;
                    all_faded = false;
                }
                else if (pitchmode == 1 && current_pitch < target_pitch)
                {
                    double new_pitch = current_pitch + amount;
                    if (new_pitch > target_pitch)
                        new_pitch = target_pitch;
                    handles[h].items[i].handle.pitch = new_pitch;
                    all_faded = false;
                }
            }
        }
        wait(pitchtime);
    }
    if (stopsounds && pitchmode == 0)
    {
        for (uint h = 0; h < handles.length(); h++)
            handles[h].pause_all();
    }
    else if (!stopsounds && pitchmode == 1)
    {
        for (uint h = 0; h < handles.length(); h++)
            handles[h].resume_all();
    }
}
void fade_volume_pool(sound_pool@[] handles, double voltime = 0.25, double target_volume = -50, int volmode = 0, bool stopsounds = true)
{
    bool all_faded = false;
    while (!all_faded)
    {
        all_faded = true;
        for (uint h = 0; h < handles.length(); h++)
        {
            for (uint x = 0; x < handles[h].items.length(); x++)
            {
                if (@handles[h].items[x].handle == null || !handles[h].items[x].handle.playing)
                    continue;
                double v = handles[h].items[x].handle.volume;
                if (volmode == 0 && v > target_volume)
                {
                    handles[h].items[x].handle.volume = max(target_volume, v - voltime);
                    all_faded = false;
                }
                else if (volmode == 1 && v < target_volume)
                {
                    handles[h].items[x].handle.volume = min(target_volume, v + voltime);
                    all_faded = false;
                }
            }
        }
        wait(5);
    }
    if (stopsounds && volmode == 0)
    {
        for (uint h = 0; h < handles.length(); h++)
            handles[h].destroy_all();
    }
}

void pause_pools()
{
sound_pool@[] pools = {p, pool, alarmpool, ambpool, bulletpool, dartpool, doorpool, heartpool, healpool, objpool, muspool, thiefpool, bosspool, carpool, gardpool, keypool, toypool};
    for(uint h = 0; h < pools.length(); h++)
    {
        for(uint i = 0; i < pools[h].items.length(); i++)
        {
            if(@pools[h].items[i].handle == null)
                continue;
            if(pools[h].items[i].handle.playing == false)
                continue;
            pools[h].pause_sound(i);
        }
    }
}
void resume_pools()
{
sound_pool@[] pools = {p, pool, alarmpool, ambpool, bulletpool, dartpool, doorpool, heartpool, healpool, objpool, muspool, thiefpool, bosspool, carpool, gardpool, keypool, toypool};
    for(uint h = 0; h < pools.length(); h++)
    {
        for(uint i = 0; i < pools[h].items.length(); i++)
        {
            pools[h].resume_sound(i);
        }
    }
}
void restart(string appid, string scriptid="tm.nvgt")
{
if(SCRIPT_COMPILED)
{
bool success=run(appid,"",false,false);
if(!success)
{
alert("errorr", "Unable to restart "+appid+"!");
}
}
else
{
bool success=run("c:\\nvgt\\nvgtw.exe", scriptid,false,false);
if(!success)
{
alert("errorr", "Unable to restart "+scriptid+"!");
}
}
exit();
}
