string currentlangfile = "none";
dictionary g_lang;
file langfile;
array<string> list_languages()
{
    array<string> result;
    string[] normalLangs = find_files("data/lang/normal/*.lng");
    for (uint i = 0; i < normalLangs.length(); i++)
    {
        string name = strip_extension(strip_directory(normalLangs[i]));
        result.insert_last(name);
    }
    string[] variantLangDirs = find_directories("data/lang/variants/*");
    for (uint i = 0; i < variantLangDirs.length(); i++)
    {
        string langFolder = strip_directory(variantLangDirs[i]);
        string[] variants = find_files("data/lang/variants/" + langFolder + "/*.lng");
        for (uint j = 0; j < variants.length(); j++)
        {
            string variantName = strip_extension(strip_directory(variants[j]));
            result.insert_last(langFolder + "/" + variantName);
        }
    }
    result.sort_ascending();
    return result;
}
string clean_key(string key)
{
    key = trim(key).lower();
    string cleaned = "";
    for (uint i = 0; i < key.length(); i++)
    {
        string c = key.substr(i, 1);
        if (c != "." && c != ":" && c != "(" && c != ")")
            cleaned += c;
    }
    return cleaned;
}
string trl(string key)
{
if (currentlangfile.lower() == "none") return key;
string cleanedKey = clean_key(remove_digits(key));
if (!g_lang.exists(cleanedKey))
return key;
return string(g_lang[cleanedKey]);
}
string trl_check(const string& in key)
{
string baseKey = remove_digits(key);
string translated = trl(key);
if (translated == key && currentlangfile.lower() != "none")
{
check_translations({baseKey});
}
return translated;
}
void check_translations(string[] phrases)
{
if (currentlangfile.lower() == "none") return;
string path;
if (currentlangfile.find("/") != -1)
{
string[] parts = string_split(currentlangfile, "/");
if (parts.length() == 2)
path = "data/lang/variants/" + parts[0] + "/" + parts[1] + ".lng";
}
else
{
path = "data/lang/normal/" + currentlangfile + ".lng";
}
string[] lines;
file reader;
if (reader.open(path, "r"))
{
lines = string_split(reader.read(), "\r\n", true);
reader.close();
}
array<string> missing;
for (uint p = 0; p < phrases.length(); p++)
{
string stripped = remove_digits(phrases[p]);
string line = stripped + "=" + stripped;
bool found = false;
for (uint i = 0; i < lines.length(); i++)
{
if (trim(lines[i]) == line)
{
found = true;
break;
}
}
if (!found) missing.insert_last(line);
}
if (missing.length() > 0)
{
lines.insert_last(missing);
lines.sort_ascending();
file writer;
if (writer.open(path, "w"))
{
for (uint i = 0; i < lines.length(); i++)
writer.write(lines[i] + "\r\n");
writer.close();
}
}
}
void load_language(string langfile)
{
    g_lang.clear();
    if (langfile.lower() == "none")
{
        currentlangfile = "None";
        writepreffs();
        return;
    }
    bool fallback = false;
    string filepath;
    if (langfile.find("/") != -1)
{
        string[] parts = string_split(langfile, "/");
        if (parts.length() == 2)
{
            filepath = "data/lang/variants/" + parts[0] + "/" + parts[1] + ".lng";
        }
else
{
            alert("Error", "Invalid language path format: " + langfile + ". Falling back to English.");
            langfile = "English";
            filepath = "data/lang/normal/English.lng";
            fallback = true;
        }
    }
else
{
        filepath = "data/lang/normal/" + langfile + ".lng";
    }
    string content = get_file_contents(filepath);
    if (trim(content) == "")
{
        if (langfile != "English")
{
            alert("Error", "The language file " + filepath + " is missing or empty. Falling back to English.");
            fallback = true;
            langfile = "English";
            filepath = "data/lang/normal/English.lng";
            content = get_file_contents(filepath);
        }
        if (trim(content) == "")
{
            alert("Error", "The fallback language file English.lng is missing or empty. Cannot continue.");
            exit();
        }
    }
    string[] lines = string_split(content, "\r\n");
    bool foundValidEntry = false;
    for (uint i = 0; i < lines.length(); i++)
{
        string line = trim(lines[i]);
        if (line == "" || line[0] == ';' || line[0] == '#') continue;
        int eq = line.find("=");
        if (eq > 0)
{
            string key = trim(line.substr(0, eq));
            string value = trim(line.substr(eq + 1));
            g_lang.set(clean_key(key), value);
            foundValidEntry = true;
        }
    }
    if (!foundValidEntry)
{
        if (langfile != "English")
{
            alert("Error", "The language file " + filepath + " contained no valid entries. Falling back to English.");
            fallback = true;
            load_language("English"); // Recursively retry with fallback
            return;
        }
else
{
            alert("Error", "The fallback language file English.lng contains no valid entries. Cannot continue.");
            exit();
        }
    }
    currentlangfile = fallback ? "English" : langfile;
    writepreffs();
    sort_language_file(filepath);
}
void sort_language_file(string path) {
string[] lines;
file reader;
if (reader.open(path, "r")) {
lines = string_split(reader.read(), "\r\n", true);
reader.close();
}
array<string> filtered;
for (uint i = 0; i < lines.length(); i++) {
string line = trim(lines[i]);
if (line == "" || line[0] == ';' || line[0] == '#') continue;
filtered.insert_last(line);
}
filtered.sort_ascending();
file writer;
if (writer.open(path, "w")) {
for (uint i = 0; i < filtered.length(); i++)
writer.write(filtered[i] + "\r\n");
writer.close();
}
}
