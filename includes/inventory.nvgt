int invpos;
dictionary inv;
void give(string item, int amount)
{
int a;
if (!inv.exists(item))
{
inv.set(item,amount);
}
else
{
inv.get(item,a);
if (a+amount<=0)
inv.delete(item);
else
inv.set(item,a+amount);
}
}
void clear_inv()
{
inv.delete_all();
}
void cycle_inv(int dir)
{
if (inv.get_size() == 0)
{
p.destroy_sound(invslot);
speak("empty");
return;
}
invslot = p.play_stationary(get_sound("misc/player/*inv*"), false);
if (dir == 1)
invpos += 1;
else
invpos -= 1;
if (invpos >= inv.get_size())
invpos = 0;
else if (invpos < 0)
invpos = inv.get_size() - 1;
int a;
inv.get(inv.get_keys()[invpos], a);
if (a == 1)
speak(inv.get_keys()[invpos] + ". Item " + (invpos + 1) + " of " + inv.get_keys().length());
else
speak(inv.get_keys()[invpos] + "s, " + a + ". Item " + (invpos + 1) + " of " + inv.get_keys().length());
}
void useitem(string current, bool block_desc=false)
{
if (inv.get_size()<=0)
{
speak("No items");
}
else
{
invpos = inv.get_keys().find(current);
string[] keycats = {"common", "other"};
for (uint i = 0; i < keycats.length(); i++)
{
string keycat = keycats[i];
string[] keytypes = find_directories("sounds/" + soundpack + "/equipments/items/normal/keys/" + keycat + "/*");
for (uint j = 0; j < keytypes.length(); j++)
{
string keyname = keytypes[j];
if (current == keyname)
{
string path = "sounds/" + soundpack + "/equipments/items/normal/keys/" + keycat + "/" + keyname + "/info.tmf";
if (file_exists(path))
{
keyfile.open(path, "rb");
keydesc = keyfile.read();
keyfile.close();
if (block_desc)
{
boss_timer.pause();
gametimer.pause();
dlgmessage_return(keydesc);
invmenu();
}
else
{
speak(keydesc);
return;
}
}
else
{
speak("No description available for " + keyname + ".");
return;
}
}
}
}
string[] objcats = {"common", "other"};
for (uint i = 0; i < objcats.length(); i++)
{
string objcat = objcats[i];
string[] objtypes = find_directories("sounds/" + soundpack + "/equipments/items/endless/" + objcat + "/*");
for (uint j = 0; j < objtypes.length(); j++)
{
string objname = objtypes[j];
if (current == objname)
{
if (objname == "ammo_pack")
{
double missing_ammo = max(0, max_reserved_ammo - reserved_ammo);
if (missing_ammo == 0)
{
speak("You already have enough reserved ammo for this weapon.");
return;
}
itemslot = p.play_stationary(get_sound("equipments/items/endless/"+objcat+"/"+objname+"/*use*"), false);
give("ammo_pack", -1);
double ammo_gained = min(random(5, 10), missing_ammo);
reserved_ammo += ammo_gained;
speak("You received " + round(ammo_gained, 0) + " rounds of ammo from the pack for this weapon.");
return;
}
else if (objname == "stun_dart")
{
itemslot = p.play_stationary(get_sound("equipments/items/endless/"+objcat+"/"+objname+"/*fire*"), false);
give("stun_dart", -1);
spawn_dart(me.x, me.y, 5, 10, random(5, 10), 30, facing);
return;
}
else if (objname == "health_potion")
{
if (health >= maxhealth)
{
speak("You don't need to use this!");
return;
}
itemslot = p.play_stationary(get_sound("equipments/items/endless/"+objcat+"/"+objname+"/*use*"), false);
itemslot = p.play_stationary(get_sound("misc/player/*heal*"), false);
give("health_potion", -1);
double heal_percent = random(5, 10);
double heal_amount = maxhealth * (heal_percent / 100.0);
health = min(health + heal_amount, maxhealth);
speak("Healed to " + round(health / maxhealth * 100, 0) + " percent HP.");
return;
}
else if (objname == "player_teleporter")
{
itemslot = p.play_stationary(get_sound("equipments/items/endless/"+objcat+"/"+objname+"/*use*"), false);
give("player_teleporter", -1);
me.x = random(0, maxx);
me.y = random(0, maxy);
speak("Moved to " + me.x + ", " + me.y + ".");
return;
}
string path = "equipments/items/endless/" + objcat + "/" + objname + "/";
string usesnd = get_sound(path + "*use*");
if (usesnd != "")
{
itemslot = p.play_stationary(usesnd, false);
}
if (file_exists(path + "info.tmf"))
{
objfile.open(path + "info.tmf", "rb");
objdesc = objfile.read();
objfile.close();
if (block_desc)
{
boss_timer.pause();
gametimer.pause();
dlgmessage_return(objdesc);
invmenu();
}
else
{
speak(objdesc);
return;
}
}
else
{
speak("Used " + objname + ".");
}
give(objname, -1);
return;
}
}
}
string[] toycats = {"common", "other"};
for (uint i = 0; i < toycats.length(); i++)
{
string toycat = toycats[i];
string[] toytypes = find_directories("sounds/" + soundpack + "/equipments/items/normal/toys/" + toycat + "/*");
for (uint j = 0; j < toytypes.length(); j++)
{
string toyname = toytypes[j];
if (current == toyname)
{
string path = "sounds/" + soundpack + "/equipments/items/normal/toys/" + toycat + "/" + toyname + "/info.tmf";
if (file_exists(path))
{
toyfile.open(path, "rb");
toydesc = toyfile.read();
toyfile.close();
if (block_desc)
{
boss_timer.pause();
gametimer.pause();
dlgmessage_return(toydesc);
invmenu();
}
else
{
speak(toydesc);
return;
}
}
else
{
speak("No description available for " + toyname + ".");
return;
}
}
}
}
}
}
int count_total_items()
{
return inv.get_keys().length();
}
string getitem()
{
if (inv.get_size()<=0)
{
return "";
}
else
{
string current=inv.get_keys()[invpos];
return current;
}
}
int item_exists(string item)
{
string[] current=inv.get_keys();
int index=current.find(item);
if (index>-1)
{
int ab;
inv.get(current[index],ab);
return ab;
}
else
return -1;
}
