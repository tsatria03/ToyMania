buffer@[]buffers(0);
int bufferpos=0;
class buffer_item
{
string name;
buffer_item(string n)
{
name=n;
}
}class buffer
{
string name;
bool interrupt=false;
bool muted=false;
buffer_item@[]items;
int bpos;
buffer(string n)
{
name=n;
}
void toggle_mute()
{
if(name=="alerts" or name=="all")
{
speak("This buffer can not be muted.",true);
}
else
{
muted = !muted;
if (togglesound==true) spool.play_stationary(get_sound(muted ? "ui/other/*disable*" : "ui/other/*enable*"), false);
speak(name + " " + (muted ? "muted" : "unmuted"), true);
}
}
}
int get_buffer_index(string name)
{
for(uint i=0; i<buffers.length(); i++)
{
if(buffers[i].name==name) return i;
}
return -1;
}
void create_buffer(string name)
{
if(get_buffer_index("all")<=-1)
{
buffer allbuffer("all");
buffers.insert_last(allbuffer);
}
buffer buffer1(name);
buffers.insert_last(buffer1);
}
void add_buffer_item(string buffername, string itemname, bool speakMessage = true)
{
int b = get_buffer_index(buffername);
if (b <= -1) return;
buffer_item temp(itemname);
buffers[b].items.insert_last(temp);
if (!buffers[0].muted && buffername != "all") {
buffers[0].items.insert_last(temp);
}
if (!buffers[b].muted && speakMessage) {
speak(itemname, true);
}
}
bool export_current_buffer()
{
if (bufferpos < 0 || bufferpos >= buffers.length())
return false;
buffer@ b = buffers[bufferpos];
if (b.items.length() == 0)
{
speak("There's nothing to export in this buffer.");
return false;
}
string bufferdir = "data/logs";
if (!directory_exists(bufferdir)) directory_create(bufferdir);
logfile.open(bufferdir + "/" + b.name + ".log", "ab");
logfile.write("Exported on " + DATE_MONTH + "/" + DATE_DAY + "/" + DATE_YEAR + "\r\n\r\n");
string bdata = "";
for (uint i2 = 0; i2 < b.items.length(); i2++)
{
bdata += b.items[i2].name + "\r\n";
}
logfile.write(bdata);
logfile.close();
if (copexpsounds==true) spool.play_stationary(get_sound("ui/other/*export*"), false);
speak(b.name + " exported");
return true;
}
bool export_all_buffers()
{
string bufferdir = "data/logs";
if (!directory_exists(bufferdir)) directory_create(bufferdir);
bool exported = false;
for (uint i = 0; i < buffers.length(); i++)
{
if (buffers[i].items.length() > 0)
{
exported = true;
logfile.open(bufferdir + "/" + buffers[i].name + ".log", "ab");
logfile.write("Exported on " + DATE_MONTH + "/" + DATE_DAY + "/" + DATE_YEAR + "\r\n\r\n");
string bdata = "";
for (uint i2 = 0; i2 < buffers[i].items.length(); i2++)
{
bdata += buffers[i].items[i2].name + "\r\n";
}
logfile.write(bdata);
logfile.close();
}
}
if (exported)
{
if (copexpsounds==true) spool.play_stationary(get_sound("ui/other/*export*"), false);
speak("All buffers exported");
return true;
}
else
{
speak("There's nothing to export in these buffers.");
return false;
}
}
void toggle_buffer()
{
if(bufferpos<0 or bufferpos>buffers.length()-1)
{
return;
}
else{
buffers[bufferpos].toggle_mute();
}
}
void next_buffer()
{
if(bufferpos>=buffers.length()-1)
{
bufferpos=buffers.length()-1;
}
else{
bufferpos++;
}
spool.play_stationary_extended(get_sound("ui/other/*switch*"),false,0,(bufferpos*100/buffers.length())-25,0,100,false);
speak(buffers[bufferpos].name + (buffers[bufferpos].muted ? ", muted, " : ", ") + (buffers[bufferpos].items.length() > 0 ? (buffers[bufferpos].bpos + 1) + " of " + buffers[bufferpos].items.length() : "empty") + ".", true);
}
void previous_buffer()
{
if(bufferpos<=0)
{
bufferpos=0;
}
else{
bufferpos--;
}
spool.play_stationary_extended(get_sound("ui/other/*switch*"),false,0,(bufferpos*100/buffers.length())-25,0,100,false);
speak(buffers[bufferpos].name + (buffers[bufferpos].muted ? ", muted, " : ", ") + (buffers[bufferpos].items.length() > 0 ? (buffers[bufferpos].bpos + 1) + " of " + buffers[bufferpos].items.length() : "empty") + ". ", true);
}
void next_buffer_item()
{
if(buffers[bufferpos].items.length()<=0)
{
speak("Empty.");
return;
}
if(buffers[bufferpos].bpos>=buffers[bufferpos].items.length()-1)
{
buffers[bufferpos].bpos=buffers[bufferpos].items.length()-1;
return;
}
else
{
buffers[bufferpos].bpos++;
}
spool.play_stationary_extended(get_sound("ui/other/*choose*"),false,0,(buffers[bufferpos].bpos*100/buffers[bufferpos].items.length())-60,0,(buffers[bufferpos].bpos*100/buffers[bufferpos].items.length())-5,false);
speak(buffers[bufferpos].items[buffers[bufferpos].bpos].name);
}
void previous_buffer_item()
{
if(buffers[bufferpos].items.length()<=0)
{
speak("Empty.");
return;
}
if(buffers[bufferpos].bpos<=0)
{
buffers[bufferpos].bpos=0;
return;
}
else
{
buffers[bufferpos].bpos--;
}
spool.play_stationary_extended(get_sound("ui/other/*choose*"),false,0,(buffers[bufferpos].bpos*100/buffers[bufferpos].items.length())-60,0,(buffers[bufferpos].bpos*100/buffers[bufferpos].items.length())-5,false);
speak(buffers[bufferpos].items[buffers[bufferpos].bpos].name);
}
void top_buffer_item()
{
if(buffers[bufferpos].items.length()==0)
{
speak("Empty.");
return;
}
buffers[bufferpos].bpos=0;
p.play_stationary_extended(get_sound("ui/other/*choose*"),false,0,(buffers[bufferpos].bpos*100/buffers[bufferpos].items.length())-60,0,(buffers[bufferpos].bpos*100/buffers[bufferpos].items.length())-5,false);
speak(buffers[bufferpos].items[buffers[bufferpos].bpos].name);
}
void bottom_buffer_item()
{
if(buffers[bufferpos].items.length()==0)
{
speak("Empty.");
return;
}
buffers[bufferpos].bpos=buffers[bufferpos].items.length()-1;
p.play_stationary_extended(get_sound("ui/other/*choose*"),false,0,(buffers[bufferpos].bpos*100/buffers[bufferpos].items.length())-60,0,(buffers[bufferpos].bpos*100/buffers[bufferpos].items.length())-5,false);
speak(buffers[bufferpos].items[buffers[bufferpos].bpos].name);
}
void copy_buffer_item()
{
if(buffers[bufferpos].items.length()<=0)
{
speak("There's nothing to copy in this buffer.");
return;
}
clipboard_copy_text(buffers[bufferpos].items[buffers[bufferpos].bpos].name);
if(copexpsounds==true) spool.play_stationary(get_sound("ui/other/*copy*"), false);
speak("Message copied",true);
}
void clear_current_buffer()
{
if (bufferpos < 0 || bufferpos >= buffers.length())
return;
buffers[bufferpos].items.resize(0);
buffers[bufferpos].bpos = 0;
}
void clear_all_buffers()
{
for (uint i = 0; i < buffers.length(); i++)
{
buffers[i].items.resize(0);
buffers[i].bpos = 0;
}
}

void buffercheck()
{
if(key_repeating(KEY_COMMA) and paused==false)
{
if (key_down(KEY_LSHIFT) or key_down(KEY_RSHIFT))
{
top_buffer_item();
}
else
{
previous_buffer_item();
}
}
if(key_repeating(KEY_PERIOD) and paused==false)
{
if (key_down(KEY_LSHIFT) or key_down(KEY_RSHIFT))
{
bottom_buffer_item();
}
else
{
next_buffer_item();
}
}
if(key_repeating(KEY_LBRACKET) and paused==false)
{
previous_buffer();
}
if(key_repeating(KEY_RBRACKET) and paused==false)
{
next_buffer();
}
if (shift_is_down())
{
if (key_repeating(KEY_M) and paused==false)
{
toggle_buffer();
}
if (key_repeating(KEY_C) and paused==false)
{
copy_buffer_item();
}
if (key_repeating(KEY_BACKSLASH) and paused==false)
{
if (export_current_buffer())
{
clear_current_buffer();
}
}
}
}
