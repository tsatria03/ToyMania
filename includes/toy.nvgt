toy@[]toys(0);
class toy
{
bool autobreak;
int getsound, hurtsound, toysound;
int tx;
int ty;
int timeout;
string toytype;
string toytype2;
timer timeout_timer;
toy(int x,int y,int tt,string tot,string tot2,bool br)
{
tx=x;
ty=y;
timeout=tt;
toytype=tot;
toytype2=tot2;
autobreak=br;
toysound=toypool.play_2d(find_sound("sounds/"+soundpack+"/equipments/items/normal/toys/"+toytype+"/"+toytype2+"/*loop*"), me.x, me.y, tx, ty, true);
toypool.update_sound_2d(toysound,tx,ty);
}
}
void toyloop()
{
for(uint i=0; i<toys.length(); i++)
{
if(toys[i].timeout_timer.elapsed>=toys[i].timeout and toys[i].autobreak==true)
{
toypool.destroy_sound(toys[i].toysound);
toys[i].hurtsound=toypool.play_2d(find_sound("sounds/"+soundpack+"/equipments/items/normal/toys/"+toys[i].toytype+"/"+toys[i].toytype2+"/*break*"), me.x, me.y, toys[i].tx, toys[i].ty, false);
toys.remove_at(i);
return;
}
if(absolute(me.x - toys[i].tx) <= 2 and absolute(me.y - toys[i].ty) <= 2 and doormove == false)
{
toypool.destroy_sound(toys[i].toysound);
toys[i].getsound=toypool.play_stationary(find_sound("sounds/"+soundpack+"/equipments/items/normal/toys/"+toys[i].toytype+"/"+toys[i].toytype2+"/*get*"),false);
p.play_stationary(find_sound("sounds/"+soundpack+"/misc/player/*give*"),false);
give(toys[i].toytype2, 1);
if(speak_item_collects==true) speak(toys[i].toytype2);
collected_toys+=1;
total_collected_toys+=1;
update_achievements();
writedata();
toys.remove_at(i);
return;
}
}
}
void spawn_toy(int x,int y,int timeout,string toytype,string toytype2,bool autobreak)
{
toy toy1(x,y,timeout,toytype,toytype2,autobreak);
toys.insert_last(toy1);
}
void destroy_all_toys()
{
for(uint i=0; i<toys.length(); i++)
{
toypool.destroy_sound(toys[i].toysound);
}
toys.resize(0);
}
